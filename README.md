# Домашнее задание #8 - goit-web-hw-08

## Первая часть

У нас есть  json файл с авторами и их свойствами: дата и место рождения, описание биографии.
Также у нас есть следующий  json файл с цитатами от этих авторов.

### Порядок выполнения

1. Создайте облачную базу данных  Atlas MongoDB

2. С помощью  ODM Mongoengine  создайте модели для хранения данных из этих файлов в коллекциях  authors и  quotes.
3. При хранении цитат (quotes) поле автора в документе должно быть не строчным значением, а Reference fields полем, где хранится   из коллекции  . ObjectIDauthors
4. Напишите скрипты для загрузки  json файлов в облачную базу данных.
5. Реализуйте скрипт для поиска цитат по тегу, имени автора или набору тегов. Скрипт выполняется в бесконечном цикле и с помощью обычного оператора  input принимает команды в следующем формате  команда: значення. Пример:

```bash
name: Steve Martin — найти и вернуть список всех цитат автора  Steve Martin;

tag:life — найти и вернуть список цитат для тега  life;

tags:life,live — найти и вернуть список цитат, где есть теги  life или  live ( примечание: без пробелов между тегами  life, live);

exit - завершить исполнение скрипта;
```

6. Вывод результатов поиска только в формате  utf-8;



### Дополнительная задача

Подумайте и реализуйте для команд  name:Steve Martin и  tag:life возможность сокращенной записи значений для поиска, как  name:st и  tag:li соответственно;

Выполните кэширование результата выполнения команд  name: и  tag: с помощью  Redis , чтобы при повторном запросе результат поиска брался не из  MongoDB  базы данных, а из кэша;

## Вторая часть

Напишите два скрипта:  consumer.py и  producer.py. Используя  RabbitMQ , организуйте с помощью очередей имитацию рассылки  email  контактам.



Используя ODM Mongoengine, создайте модель контакта. Модель обязательно должна включать поля: полное имя, email и логическое поле, имеющее значение  False по умолчанию. Оно означает, что сообщение контакта не отправлено и должно стать  True, когда будет отправлено. Остальные поля для информационной нагрузки можете придумать сами.



При запуске скрипта  producer.py он создает определенное количество фейковых контактов и записывает их в базу данных. Затем помещает в очередь  RabbitMQ  сообщение, содержащее  ObjectID созданного контакта, и так для всех сгенерированных контактов.



Скрипт  consumer.py получает из очереди  RabbitMQ  сообщение, обрабатывает его и имитирует  функцию-заглушку  отправки сообщения по email. После передачи сообщения необходимо логическое поле для контакта установить в  True. Скрипт работает постоянно в ожидании сообщений с  RabbitMQ.

## Додаткове завдання​



Введіть у моделі додаткове поле телефонний номер. Також додайте поле, що відповідає за кращий спосіб надсилання повідомлень — SMS по телефону або email. Нехай producer.py відправляє у різні черги контакти для SMS та email. Створіть два скрипти consumer_sms.py та consumer_email.py, кожен з яких отримує свої контакти та обробляє їх.